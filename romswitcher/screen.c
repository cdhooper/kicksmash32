/*
 * Amiga screen functions, including screen scroll and text rendering.
 *
 * This source file is part of the code base for a simple Amiga ROM
 * replacement sufficient to allow programs using some parts of GadTools
 * to function.
 *
 * Copyright 2025 Chris Hooper. This program and source may be used
 * and distributed freely, for any purpose which benefits the Amiga
 * community. All redistributions must retain this Copyright notice.
 *
 * DISCLAIMER: THE SOFTWARE IS PROVIDED "AS-IS", WITHOUT ANY WARRANTY.
 * THE AUTHOR ASSUMES NO LIABILITY FOR ANY DAMAGE ARISING OUT OF THE USE
 * OR MISUSE OF THIS UTILITY OR INFORMATION REPORTED BY THIS UTILITY.
 */
#include <stdint.h>
#include <string.h>
#include "util.h"
#include "screen.h"
#include "serial.h"
#include "amiga_chipset.h"

#define SCREEN_COLUMNS 80  // SCREEN_WIDTH / 8
#define SCREEN_ROWS    26  // SCREEN_HEIGHT / 8

uint cursor_x_start;  // Upper left pixel of editor area
uint cursor_y_start;  // Upper right pixel of editor area
uint cursor_x;        // Cursor left-right column position in editor area
uint cursor_y;        // Cursor top-down row position in editor area
uint cursor_visible;  // Cursor is visible on screen
uint dbg_cursor_x;    // Debug cursor column position on screen
uint dbg_cursor_y;    // Debug cursor row position on screen
uint dbg_all_scroll;  // Number of lines where all bitplanes should scroll
uint displaybeep;     // DisplayBeep is active when non-zero

static const uint8_t
font_fixed_8x8[] =
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // " "
    0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00,  // "!"
    0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // """
    0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,  // "#"
    0x18, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x18, 0x00,  // "$"
    0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,  // "%"
    0x78, 0xcc, 0xc8, 0x76, 0xdc, 0xcc, 0x76, 0x00,  // "&"
    0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,  // "'"
    0x0c, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00,  // "("
    0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00,  // ")"
    0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,  // "*"
    0x00, 0x00, 0x18, 0x7e, 0x18, 0x00, 0x00, 0x00,  // "+"
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,  // ","
    0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,  // "-"
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,  // "."
    0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x00,  // "/"
    0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,  // "0"
    0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,  // "1"
    0x7c, 0xc6, 0x06, 0x1c, 0x30, 0x60, 0xfe, 0x00,  // "2"
    0x7c, 0xc6, 0x06, 0x1c, 0x06, 0xc6, 0x7c, 0x00,  // "3"
    0x0c, 0xcc, 0xcc, 0xcc, 0xfe, 0x0c, 0x0c, 0x00,  // "4"
    0xfe, 0xc0, 0xfc, 0x06, 0x06, 0xc6, 0x7c, 0x00,  // "5"
    0x3c, 0x60, 0xc0, 0xfc, 0xc6, 0xc6, 0x7c, 0x00,  // "6"
    0xfe, 0xc6, 0x06, 0x0c, 0x18, 0x18, 0x18, 0x00,  // "7"
    0x7c, 0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0x7c, 0x00,  // "8"
    0x7c, 0xc6, 0xc6, 0x7e, 0x06, 0x0c, 0x78, 0x00,  // "9"
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,  // ":"
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,  // ";"
    0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x00,  // "<"
    0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00,  // "="
    0x30, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x00,  // ">"
    0x7c, 0xc6, 0x06, 0x0c, 0x18, 0x00, 0x18, 0x00,  // "?"
    0x7c, 0xc6, 0xde, 0xd6, 0xde, 0xc0, 0x7c, 0x00,  // "@"
    0x7c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00,  // "A"
    0xfc, 0xc6, 0xc6, 0xfc, 0xc6, 0xc6, 0xfc, 0x00,  // "B"
    0x7c, 0xc6, 0xc0, 0xc0, 0xc0, 0xc6, 0x7c, 0x00,  // "C"
    0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00,  // "D"
    0xfe, 0xc0, 0xc0, 0xf8, 0xc0, 0xc0, 0xfe, 0x00,  // "E"
    0xfe, 0xc0, 0xc0, 0xf8, 0xc0, 0xc0, 0xc0, 0x00,  // "F"
    0x7c, 0xc6, 0xc0, 0xce, 0xc6, 0xc6, 0x7c, 0x00,  // "G"
    0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00,  // "H"
    0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00,  // "I"
    0x06, 0x06, 0x06, 0x06, 0xc6, 0xc6, 0x7c, 0x00,  // "J"
    0xc6, 0xc6, 0xcc, 0xf8, 0xcc, 0xc6, 0xc6, 0x00,  // "K"
    0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0x00,  // "L"
    0x82, 0xc6, 0xee, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,  // "M"
    0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,  // "N"
    0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  // "O"
    0xfc, 0xc6, 0xc6, 0xfc, 0xc0, 0xc0, 0xc0, 0x00,  // "P"
    0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xde, 0x7c, 0x06,  // "Q"
    0xfc, 0xc6, 0xc6, 0xfc, 0xc6, 0xc6, 0xc6, 0x00,  // "R"
    0x7c, 0xc6, 0xc0, 0x7c, 0x06, 0xc6, 0x7c, 0x00,  // "S"
    0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,  // "T"
    0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00,  // "U"
    0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00,  // "V"
    0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,  // "W"
    0xc6, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0xc6, 0x00,  // "X"
    0xc3, 0xc3, 0xc3, 0x7e, 0x18, 0x18, 0x18, 0x00,  // "Y"
    0xfe, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0xfe, 0x00,  // "Z"
    0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00,  // "["
    0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x00,  // "\"
    0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00,  // "]"
    0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,  // "^"
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,  // "_"
    0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,  // "`"
    0x00, 0x00, 0x7c, 0x06, 0x7e, 0xc6, 0x7e, 0x00,  // "a"
    0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0xfc, 0x00,  // "b"
    0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc6, 0x7c, 0x00,  // "c"
    0x06, 0x06, 0x7e, 0xc6, 0xc6, 0xc6, 0x7e, 0x00,  // "d"
    0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0x7c, 0x00,  // "e"
    0x1c, 0x36, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00,  // "f"
    0x00, 0x00, 0x7e, 0xc6, 0xc6, 0x7e, 0x06, 0x7c,  // "g"
    0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,  // "h"
    0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,  // "i"
    0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0xc6, 0x7c,  // "j"
    0xc0, 0xc0, 0xcc, 0xd8, 0xf8, 0xcc, 0xc6, 0x00,  // "k"
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,  // "l"
    0x00, 0x00, 0xec, 0xfe, 0xd6, 0xd6, 0xc6, 0x00,  // "m"
    0x00, 0x00, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,  // "n"
    0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  // "o"
    0x00, 0x00, 0xfc, 0xc6, 0xc6, 0xfc, 0xc0, 0xc0,  // "p"
    0x00, 0x00, 0x7e, 0xc6, 0xc6, 0x7e, 0x06, 0x06,  // "q"
    0x00, 0x00, 0xfc, 0xc6, 0xc0, 0xc0, 0xc0, 0x00,  // "r"
    0x00, 0x00, 0x7e, 0xc0, 0x7c, 0x06, 0xfc, 0x00,  // "s"
    0x18, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x0c, 0x00,  // "t"
    0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00,  // "u"
    0x00, 0x00, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00,  // "v"
    0x00, 0x00, 0xc6, 0xd6, 0xd6, 0x6c, 0x6c, 0x00,  // "w"
    0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,  // "x"
    0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x7c,  // "y"
    0x00, 0x00, 0xfe, 0x0c, 0x38, 0x60, 0xfe, 0x00,  // "z"
    0x0e, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0e, 0x00,  // "{"
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,  // "|"
    0x70, 0x18, 0x18, 0x0e, 0x18, 0x18, 0x70, 0x00,  // "}"
    0x72, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // "~"
    0xcc, 0x33, 0xcc, 0x33, 0xcc, 0x33, 0xcc, 0x33,  // ""
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "Ä"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "Å"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "Ç"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "É"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "Ñ"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "Ö"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "Ü"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "á"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "à"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "â"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ä"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ã"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "å"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ç"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "é"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "è"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ê"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ë"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "í"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ì"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "î"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ï"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ñ"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ó"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ò"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ô"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ö"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "õ"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ú"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ù"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "û"
    0x7e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,  // "ü"
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // "†"
    0x7c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x03,  // "°"
    0x0c, 0x3e, 0x6c, 0x6c, 0x3e, 0x0c, 0x00, 0x00,  // "¢"
    0xc0, 0xc0, 0xd8, 0xf0, 0xe0, 0xc0, 0xfe, 0x00,  // "£"
    0x42, 0x3c, 0x66, 0x3c, 0x42, 0x00, 0x00, 0x00,  // "§"
    0x66, 0x66, 0x3c, 0x18, 0x3c, 0x18, 0x18, 0x00,  // "•"
    0x18, 0x7c, 0xc6, 0x70, 0x1e, 0xc6, 0x7c, 0x00,  // "¶"
    0x3c, 0x40, 0x3c, 0x66, 0x3c, 0x02, 0x3c, 0x00,  // "ß"
    0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // "®"
    0x3c, 0x42, 0x99, 0xa1, 0xa1, 0x99, 0x42, 0x3c,  // "©"
    0x3e, 0x66, 0x66, 0x3e, 0x00, 0x7e, 0x00, 0x00,  // "™"
    0x00, 0x33, 0x66, 0xcc, 0x66, 0x33, 0x00, 0x00,  // "´"
    0x60, 0xfe, 0x4c, 0x18, 0x30, 0x60, 0xfe, 0x00,  // "¨"
    0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,  // "≠"
    0x3c, 0x42, 0xb9, 0xa5, 0xb9, 0xa5, 0x42, 0x3c,  // "Æ"
    0x30, 0xfe, 0x18, 0x30, 0x60, 0xc0, 0xfe, 0x00,  // "Ø"
    0x3c, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,  // "∞"
    0x00, 0x00, 0x7c, 0x06, 0x7e, 0xc6, 0x7e, 0x03,  // "±"
    0x38, 0x4c, 0x18, 0x30, 0x7c, 0x00, 0x00, 0x00,  // "≤"
    0x18, 0x18, 0x1c, 0x18, 0x38, 0x18, 0x18, 0x00,  // "≥"
    0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // "¥"
    0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc0,  // "µ"
    0x18, 0x30, 0x7e, 0xc0, 0x7c, 0x06, 0xfc, 0x00,  // "∂"
    0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,  // "∑"
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30,  // "∏"
    0x18, 0x38, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00,  // "π"
    0x3c, 0x66, 0x66, 0x3c, 0x00, 0x7e, 0x00, 0x00,  // "∫"
    0x00, 0xcc, 0x66, 0x33, 0x66, 0xcc, 0x00, 0x00,  // "ª"
    0x18, 0x30, 0xfe, 0x0c, 0x38, 0x60, 0xfe, 0x00,  // "º"
    0x40, 0xc6, 0x4c, 0x58, 0x3e, 0x72, 0xc4, 0x0e,  // "Ω"
    0xc0, 0x63, 0xc6, 0x6c, 0xd9, 0x35, 0x67, 0x01,  // "æ"
    0x30, 0x00, 0xfe, 0x0c, 0x38, 0x60, 0xfe, 0x00,  // "ø"
    0x30, 0x18, 0x7c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00,  // "¿"
    0x18, 0x30, 0x7c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00,  // "¡"
    0x38, 0x6c, 0x7c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00,  // "¬"
    0x72, 0x9c, 0x7c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00,  // "√"
    0xc6, 0x00, 0x7c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00,  // "ƒ"
    0x7c, 0xc6, 0x7c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00,  // "≈"
    0x30, 0x7c, 0xc6, 0xc0, 0xc0, 0xc6, 0x7c, 0x00,  // "∆"
    0x7c, 0xc6, 0xc0, 0xc0, 0xc0, 0xc6, 0x7c, 0x30,  // "«"
    0x30, 0x18, 0xfe, 0xc0, 0xf8, 0xc0, 0xfe, 0x00,  // "»"
    0x18, 0x30, 0xfe, 0xc0, 0xf8, 0xc0, 0xfe, 0x00,  // "…"
    0xfe, 0xc0, 0xc0, 0xf8, 0xc0, 0xc0, 0xfe, 0x06,  // " "
    0xc6, 0x00, 0xfe, 0xc0, 0xf8, 0xc0, 0xfe, 0x00,  // "À"
    0x30, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x7e, 0x00,  // "Ã"
    0x0c, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x7e, 0x00,  // "Õ"
    0x3c, 0x66, 0x7e, 0x18, 0x18, 0x18, 0x7e, 0x00,  // "Œ"
    0x66, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x7e, 0x00,  // "œ"
    0xfc, 0xc6, 0xc6, 0xf6, 0xc6, 0xc6, 0xfc, 0x00,  // "–"
    0x18, 0xd6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0x00,  // "—"
    0x30, 0x18, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  // "“"
    0x0c, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  // "”"
    0x38, 0x6c, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  // "‘"
    0x72, 0x9c, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  // "’"
    0xc6, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  // "÷"
    0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00, 0x00,  // "◊"
    0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,  // "ÿ"
    0x30, 0x18, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00,  // "Ÿ"
    0x18, 0x30, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00,  // "⁄"
    0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00,  // "€"
    0xc6, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00,  // "‹"
    0x0c, 0x18, 0xc3, 0xc3, 0x7e, 0x18, 0x18, 0x00,  // "›"
    0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0,  // "ﬁ"
    0xfc, 0xc6, 0xc6, 0xdc, 0xc6, 0xc6, 0xdc, 0xc0,  // "ﬂ"
    0x30, 0x18, 0x7c, 0x06, 0x7e, 0xc6, 0x7e, 0x00,  // "‡"
    0x18, 0x30, 0x7c, 0x06, 0x7e, 0xc6, 0x7e, 0x00,  // "·"
    0x38, 0x6c, 0x7c, 0x06, 0x7e, 0xc6, 0x7e, 0x00,  // "‚"
    0x72, 0x9c, 0x7c, 0x06, 0x7e, 0xc6, 0x7e, 0x00,  // "„"
    0xc6, 0x00, 0x7c, 0x06, 0x7e, 0xc6, 0x7e, 0x00,  // "‰"
    0x3c, 0x66, 0x7c, 0x06, 0x7e, 0xc6, 0x7e, 0x00,  // "Â"
    0x18, 0x30, 0x7c, 0xc6, 0xc0, 0xc6, 0x7c, 0x00,  // "Ê"
    0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc6, 0x7c, 0x30,  // "Á"
    0x30, 0x18, 0x7c, 0xc6, 0xfe, 0xc0, 0x7c, 0x00,  // "Ë"
    0x18, 0x30, 0x7c, 0xc6, 0xfe, 0xc0, 0x7c, 0x00,  // "È"
    0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0x7c, 0x06,  // "Í"
    0xc6, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0x7c, 0x00,  // "Î"
    0x30, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00,  // "Ï"
    0x0c, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00,  // "Ì"
    0x3c, 0x66, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00,  // "Ó"
    0x66, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00,  // "Ô"
    0x60, 0xfc, 0x18, 0x7c, 0xc6, 0xc6, 0x7c, 0x00,  // ""
    0x18, 0x30, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0x00,  // "Ò"
    0x30, 0x18, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  // "Ú"
    0x18, 0x30, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  // "Û"
    0x38, 0x6c, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  // "Ù"
    0x72, 0x9c, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  // "ı"
    0xc6, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00,  // "ˆ"
    0x00, 0x18, 0x00, 0x7e, 0x00, 0x18, 0x00, 0x00,  // "˜"
    0x00, 0x00, 0x7c, 0xce, 0xd6, 0xe6, 0x7c, 0x00,  // "¯"
    0x30, 0x18, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00,  // "˘"
    0x18, 0x30, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00,  // "˙"
    0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00,  // "˚"
    0xc6, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x00,  // "¸"
    0x18, 0x30, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x7c,  // "˝"
    0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xfc, 0xc0, 0xc0,  // "˛"
    0xc6, 0x00, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x7c,  // "ˇ"
};

/*
 * blitter_is_busy
 * ---------------
 * Returns non-zero (true) if the blitter is busy
 */
static uint
blitter_is_busy(void)
{
    /* Test twice to cover blitter bugs (from NetBSD) */
    return ((*DMACONR & DMACON_BBUSY) ||
            (*DMACONR & DMACON_BBUSY));
}

/*
 * WaitBlit
 * --------
 * Wait until blitter is not busy
 *
 * A screen scroll was measured at about 8442 us
 *      (~9 serial characters at 9600 bps)
 */
void
WaitBlit(void)
{
    while (blitter_is_busy()) {
        __asm("nop");
        __asm("nop");
        __asm("nop");
    }
}


#if 0
void
blit(void)
{
    const uint height = 4 * 8;  // max 1024
    const uint width  = SCREEN_WIDTH / 16;  // between 1 and 64 words
    WaitBlit();

    *BLTCON0 = 0x09f0;
    *BLTCON1 = 0;
    *BLTAMOD = 0;
    *BLTDMOD = 0;
    *BLTAPTH = BITPLANE_0_BASE + SCREEN_WIDTH * 4;  // source 1
    // *BLTBPTH = 0x0000;  // source 2
    // *BLTCPTH = 0x0000;  // source 3
    *BLTDPTH = BITPLANE_0_BASE + SCREEN_WIDTH * 12;  // destination

    *BLTSIZE = (height << 6) | width;
}
#endif

void
blitter_scroll(uint bitplane)
{
    uint width  = SCREEN_WIDTH / 16;  // between 1 and 64 words
    uint height = (SCREEN_ROWS + 1) * FONT_HEIGHT;  // max 1024
    uint32_t base = BITPLANE_0_BASE + BITPLANE_OFFSET * bitplane;

    WaitBlit();

    *BLTCON0 = 0x09f0;
    *BLTCON1 = 0;
    *BLTAMOD = 0;
    *BLTDMOD = 0;
    *BLTDPTH = base;                    // destination
    *BLTAPTH = base + SCREEN_WIDTH * 1; // source

    if (height < 150) {
        *BLTSIZE = (height << 6) | width;
    } else {
        uint t_height = 150;
        *BLTSIZE = (t_height << 6) | width;
        height -= t_height;
        WaitBlit();
        *BLTCON0 = 0x09f0;
        *BLTCON1 = 0;
        *BLTAMOD = 0;
        *BLTDMOD = 0;
        *BLTDPTH = base + t_height * SCREEN_WIDTH / 8;
        *BLTAPTH = base + t_height * SCREEN_WIDTH / 8 +
                                     SCREEN_WIDTH * 1;  // next line
        *BLTSIZE = (height << 6) | width;
        WaitBlit();
    }
}

/*
 * render_char
 * -----------
 * Renders the specified character at the current cursor position
 */
static void
render_char(uint8_t ch)
{
    const uint8_t *ptr = &font_fixed_8x8[(ch - ' ') * 8];
    uint8_t *bpl = ADDR8(BITPLANE_0_BASE + dbg_cursor_x +
                         dbg_cursor_y * SCREEN_WIDTH);
    uint line;
    for (line = 0; line < FONT_HEIGHT; line++) {
        *bpl = *(ptr++);
        bpl += (SCREEN_WIDTH / 8);
    }
}

#define RENDER_BUF_CHARS 128
__attribute__((aligned(4)))
uint8_t __chip render_buf[RENDER_BUF_CHARS * FONT_HEIGHT];


/*
 * render_char_to_buf
 * ------------------
 * Copy a single character to the specified buffer.
 */
static void
render_char_to_buf(char ch, char *buf)
{
    const uint8_t *ptr = &font_fixed_8x8[(ch - ' ') * FONT_HEIGHT];
    uint line;
    for (line = 0; line < FONT_HEIGHT; line++) {
        *buf = *ptr;
        buf += RENDER_BUF_CHARS;
        ptr++;
    }
}


#include "printf.h"
/*
 * render_text_at
 * --------------
 * Draw a string at the specified screen x and y coordinates.
 * Note that x and y are specified in pixels and not cursor position.
 */
void
render_text_at(const char *str, uint maxlen, uint x, uint y,
               uint fg_color, uint bg_color)
{
    char *rbuf = render_buf;
    uint plane;
    uint len = 0;
    uint line;

    if (maxlen > RENDER_BUF_CHARS)
        maxlen = RENDER_BUF_CHARS;
    for (rbuf = render_buf; *str != '\0'; str++) {
        render_char_to_buf(*str, rbuf++);
        if ((++len == maxlen))
            break;
    }

    if ((x & 7) == 0) {
        /* Horizontal position is aligned to byte - YAY! */
        for (plane = 0; plane < SCREEN_BITPLANES; plane++) {
            uint8_t *bpl = ADDR8(BITPLANE_0_BASE + plane * BITPLANE_OFFSET +
                                 x / 8 + y * SCREEN_WIDTH / 8);
            /*
             * There are four possible fill modes:
             *   A) Empty: neither Fg nor Bg color selects this bitplane
             *   B) Invert Text: only Bg color selects this bitplane
             *   C) Text: only Fg color selects this bitplane
             *   D) Solid: both Fg and Bg color select this bitplane
             */
            if ((fg_color & BIT(plane)) == 0) {
                if ((bg_color & BIT(plane)) == 0) {
                    /* A) Empty: neither Fg nor Bg color selects bitplane */
                    for (line = 0; line < FONT_HEIGHT; line++) {
                        memset(bpl, 0, len);
                        bpl += (SCREEN_WIDTH / 8);
                    }
                } else {
                    /* B) Invert Text: only Bg color selects this bitplane */
                    for (line = 0; line < FONT_HEIGHT; line++) {
                        uint pos;
                        uint8_t *rp = render_buf + line * RENDER_BUF_CHARS;
                        for (pos = 0; pos < len; pos++)
                            bpl[pos] = *(rp++) ^ 0xff;
                        bpl += (SCREEN_WIDTH / 8);
                    }
                }
            } else {
                if ((bg_color & BIT(plane)) == 0) {
                    /* C) Text: only Fg color selects this bitplane */
                    for (line = 0; line < FONT_HEIGHT; line++) {
                        memcpy(bpl, render_buf + line * RENDER_BUF_CHARS, len);
                        bpl += (SCREEN_WIDTH / 8);
                    }
                } else {
                    /* D) Solid: both Fg and Bg color select this bitplane */
                    for (line = 0; line < FONT_HEIGHT; line++) {
                        memset(bpl, 0xff, len);
                        bpl += (SCREEN_WIDTH / 8);
                    }
                }
            }
        }
    } else {
        /* Horizontal position is not aligned to byte - BOO! */
        uint     byte;
        uint     left_start = x & ~0x7;
        uint     right_end  = (x + len * 8 + 0x7) & ~0x7;
        uint     num_bytes  = (right_end - left_start) / 8;
        uint     left_off   = x & 0x7;
        uint     right_off  = 8 - ((x + len * 8) & 0x7);
        uint8_t  left_mask  = 0xff >> left_off;
        uint8_t  right_mask = 0xff << right_off;

#if 0
        if ((x > 400) && (y < 150)) {
            printf("  %u:%u:%u:%x", x, left_start, left_off, left_mask);
            printf(" %u:%u:%u:%x",
                   x + len * 8, right_end, right_off, right_mask);
        }
#endif
        for (plane = 0; plane < SCREEN_BITPLANES; plane++) {
            uint8_t *rptr = ADDR8(BITPLANE_0_BASE + plane * BITPLANE_OFFSET +
                                  x / 8 + y * SCREEN_WIDTH / 8);
            uint8_t  fill_and;
            uint8_t  fill_xor;
            /*
             * There are four possible fill modes:
             *   A) Empty: neither Fg nor Bg color selects this bitplane
             *      and = 0x00, xor = 0x00
             *   B) Invert Text: only Bg color selects this bitplane
             *      and = 0xff, xor = 0xff
             *   C) Text: only Fg color selects this bitplane
             *      and = 0xff, xor = 0x00
             *   D) Solid: both Fg and Bg color select this bitplane
             *      and = 0x00, xor = 0xff
             */
            if ((fg_color & BIT(plane)) == 0) {
                if ((bg_color & BIT(plane)) == 0) {
                    /* A) Empty: neither Fg nor Bg color selects bitplane */
                    fill_and = 0x00;
                    fill_xor = 0x00;
                } else {
                    /* B) Invert Text: only Bg color selects this bitplane */
                    fill_and = 0xff;
                    fill_xor = 0xff;
                }
            } else {
                if ((bg_color & BIT(plane)) == 0) {
                    /* C) Text: only Fg color selects this bitplane */
                    fill_and = 0xff;
                    fill_xor = 0x00;
                } else {
                    /* D) Solid: both Fg and Bg color select this bitplane */
                    fill_and = 0x00;
                    fill_xor = 0xff;
                }
            }
//          printf("[%x %x %02x %02x]", fg_color, bg_color, fill_and, fill_xor);

            for (line = 0; line < FONT_HEIGHT; line++) {
                uint8_t *ptr = rptr;
                uint8_t *rend = ADDR8(render_buf + line * RENDER_BUF_CHARS);
                uint8_t data = (*(rend++) & fill_and) ^ fill_xor;

                /* Draw leading part of character */
                *ptr = (*ptr & ~left_mask) |
                       ((data >> left_off) & left_mask);
                ptr++;

                /* Draw body of string */
                for (byte = 1; byte < num_bytes - 1; byte++) {
                    uint8_t ndata = (*(rend++) & fill_and) ^ fill_xor;
                    *ptr = ((data << right_off) & right_mask) |
                           ((ndata >> left_off) & left_mask);
                    ptr++;
                    data = ndata;
                }

                /* Draw trailing part of character */
                *ptr = (*ptr & ~right_mask) |
                       ((data << right_off) & right_mask);
                rptr += SCREEN_WIDTH / 8;
            }
        }
    }
}

void
dbg_show_char(uint ch)
{
    switch (ch) {
        case '\r':  // Carriage return
            dbg_cursor_x = 0;
            break;
        case '\n':  // Newline
            goto next_row;
        case '\t':  // Tab
            dbg_cursor_x = (dbg_cursor_x + 8) & ~7;
            goto check_column;
        case '\b':  // Backspace
            dbg_cursor_x--;
            if (dbg_cursor_x > SCREEN_COLUMNS - 1) {
                if (dbg_cursor_y == 0) {
                    dbg_cursor_x = 0;
                    break;  // Already at top of screen
                }
                dbg_cursor_x = SCREEN_COLUMNS - 1;
                dbg_cursor_y--;
            }
            break;
        default:
            if (ch < ' ')
                ch = ' ';
            render_char(ch);
            dbg_cursor_x++;
check_column:
            if (dbg_cursor_x >= SCREEN_COLUMNS) {
                dbg_cursor_x = 0;
next_row:
                dbg_cursor_y++;
                if (dbg_cursor_y > SCREEN_ROWS - 1) {
                    dbg_cursor_y = SCREEN_ROWS - 1;
                    blitter_scroll(0);  // scroll screen
                    if (dbg_all_scroll) {
                        /* Scroll all color bitplanes */
                        dbg_all_scroll--;
                        blitter_scroll(1);
                        blitter_scroll(2);
                    }
                    /*
                     * XXX: Faster would be to double-buffer the screen
                     *      and just tell the VBlank ISR the new desired
                     *      start of screen. Blit would only need to occur
                     *      when we get to the bottom of the larger buffer,
                     *      where it would duplicate the bottom screen back
                     *      to the top.
                     */
                }
            }
            break;
    }
}

void
dbg_show_string(const uint8_t *str)
{
    while (*str != '\0') {
        if (*str == '\n')
            dbg_show_char('\r');
        dbg_show_char(*str);
        str++;
    }
}

void
screen_beep_handle(void)
{
    switch (--displaybeep) {
        case 0:
            *COLOR00 = 0x999;  // Normal
            break;
        case 1:
            *COLOR00 = 0x666;  // Gray
            break;
        case 2:
            *COLOR00 = 0x333;  // Dark gray
            break;
    }
}

void
screen_displaybeep(void)
{
    displaybeep = 3;
    *COLOR00 = 0x000;  // Black
}

void
SetRGB4(void *vp, int32_t index, uint32_t red, uint32_t green, uint32_t blue)
{
    /* Don't set any colors for now */
    (void) vp;
    (void) index;
    (void) red;
    (void) green;
    (void) blue;
}

void
screen_init(void)
{
    *BPLCON0  = BPLCON0_HIGHRES |
                (3 * BPLCON0_BPU) | // 3 bitplanes (8 colors)
                BPLCON0_ECS;        // Enable ECS
    *BPLCON1  = 0;       // Horizontal scroll = 0
//  *BPLCON2  = 1;       // Sprite (cursor) lower priority than foreground
    *BPLCON2  = 0x0008;  // Mouse Pointer Sprite > foreground > Cursor Sprite
    *BPL1MOD  = 0;       // Modulo for odd bitplanes = 0
//  *BPL1MOD  = 136;
//  *BPL2MOD  = 136;
    *BPL2MOD  = 0;       // Modulo for even bitplanes = 0
    *BPL1DAT  = 0x0;
    *COLOR00  = 0x999;   // Pen 0: Grey (background)
    *COLOR01  = 0x000;   // Pen 1: Black
    *COLOR02  = 0xfff;   // Pen 2: White
    *COLOR03  = 0x68b;   // Pen 3: Lt.Blue
    *COLOR04  = 0xdd5;   // Pen 4: Gold
    *COLOR05  = 0xa92;   // Pen 5: Gold dim
    *COLOR06  = 0x333;   // Pen 6: Dark Grey
    *COLOR07  = 0xf44;   // Pen 7: Red (unused)
    *BPL1PT   = BITPLANE_0_BASE;  // Bitplane 0 base address
    *BPL2PT   = BITPLANE_1_BASE;  // Bitplane 1 base address
    *BPL3PT   = BITPLANE_2_BASE;  // Bitplane 2 base address
    memset((void *) BITPLANE_0_BASE, 0x00, 0x10000);

    /*
     * The correct values for DIWSTRT and DIWSTTO are calculated as follows:
     * Calculation of DDFSTRT and DDFSTOP in the low-res mode:
     *   HStart = horizontal start of the screen window
     *   DDFSTRT = (HStart/2 - 8.5) AND $FFF8
     *   DDFSTOP = DDFSTRT + (pixels per line/2 - 8)
     *   This yields $81 for HStart and 320 pixels per line:
     *   DDFSTRT - ($81/2 - 8.5) AND $FFF8 = $38
     *   DDFSTOP ¬ª $38 + (320/2 - 8) - $D0
     * Calculation of DDFSTRT and DDFSTOP in the high-res mode:
     *   DDFSTRT = (HStart/2 - 4.5) AND $fFFC
     *   DDFSTOP = DDFSTRT + (pixels per line/4 - 8)
     *   This yields $81 for HStart and 640 pixels per line:
     *   DDFSTRT = ($81/2 - 4.5) AND $FFFC = $3C
     *   DDFSTOP = $3C + (640/4 - 8) = $D4
     */
    *DIWSTRT  = 0x2c81;  // Start of screen window
    *DIWSTOP  = 0x2cc1;  // End of screen window
    *DDFSTRT  = 0x3c;    // Bit plane DMA start
    *DDFSTOP  = 0xd4;    // Bit plane DMA stop

    /* Initialize the Blitter */
    *BLTAFWM  = 0xffff;
    *BLTALWM  = 0xffff;
    *BLTADAT  = 0;
    *BLTBDAT  = 0;
    *BLTCDAT  = 0;
    *BLTAPT   = 0;
    *BLTBPT   = 0;
    *BLTCPT   = 0;
    *BLTDPT   = 0;
    *BLTAMOD  = 0;
    *BLTBMOD  = 0;
    *BLTCMOD  = 0;
    *BLTDMOD  = 0;
    *BLTCON0  = 0;
    *BLTCON1  = 0;
    *BLTSIZE  = (1 << 6) | 0x1;  // 1 pixel high, 1 pixel wide

#if 0
    /* Implementation of multiscan 31.56 kHz doesn't seem to work */
    *HSSTRT   = 0x0005; // Horizontal centering
    *DDFSTRT  = 0x0018; // Bit plane DMA start
    *DDFSTOP  = 0x0058; // Bit plane DMA stop
    *FMODE    = 0xc00f; // BLP32 BPAGEM SPR32 SPAGEM  BSCAN2 SSCAN2
    *HBSTRT   = 0x0009;
    *HBSTOP   = 0x0017;
    *HTOTAL   = 0x0071;
    *VBSTRT   = 0x0000;
    *VSSTRT   = 0x0003;
    *VSSTOP   = 0x0005;
    *VBSTOP   = 0x001d;
    *VTOTAL   = 0x020e;
    *BEAMCON0 = 0x0B88;
    *BPLCON2  = 0x027f;
    *BPLCON3  = 0x00a3;
    *BPLCON4  = 0x0011;
#endif
#if 0
    /* Implementation of dblPAL 50Hz 31.00 kHz doesn't seem to work */
//  *BPLCON0  = 0xb201;
//  *HSSTRT   = 0x0005; // Horizontal centering
    *DDFSTRT  = 0x0028; // Bit plane DMA start
    *DDFSTOP  = 0x0068; // Bit plane DMA stop
    *FMODE    = 0xc00f; // BLP32 BPAGEM SPR32 SPAGEM  BSCAN2 SSCAN2
    *HBSTRT   = 0x0009;
    *HSSTOP   = 0x0025;
    *HBSTOP   = 0x0031;
    *HTOTAL   = 0x0077;
    *VBSTRT   = 0x0000;
    *VSSTRT   = 0x0003;
    *VSSTOP   = 0x0005;
    *VBSTOP   = 0x001d;
    *VTOTAL   = 0x0258;
    *BEAMCON0 = 0x0B88;
    *BPLCON1  = 0x0000;
    *BPLCON2  = 0x027f;
    *BPLCON3  = 0x00a3;
    *BPLCON4  = 0x0011;
#endif
#if 0
    /* Implementation of dblNTSC 60Hz 31.00 kHz doesn't seem to work */
//  *BPLCON0  = 0xb201;
//  *HSSTRT   = 0x0005; // Horizontal centering
    *DDFSTRT  = 0x0028; // Bit plane DMA start
    *DDFSTOP  = 0x0068; // Bit plane DMA stop
    *FMODE    = 0xc00f; // BLP32 BPAGEM SPR32 SPAGEM  BSCAN2 SSCAN2
    *HBSTRT   = 0x0009;
    *HSSTOP   = 0x0025;
    *HBSTOP   = 0x0031;
    *HTOTAL   = 0x0077;
    *VBSTRT   = 0x0000;
    *VSSTRT   = 0x0003;
    *VSSTOP   = 0x0005;
    *VBSTOP   = 0x001d;
    *VTOTAL   = 0x01f4;
    *BEAMCON0 = 0x0b88;
    *BPLCON1  = 0x0000;
    *BPLCON2  = 0x027f;
    *BPLCON3  = 0x00a3;
    *BPLCON4  = 0x0011;
#endif

    serial_puts("\bB");

    *DMACON   = DMACON_SET |     // Enable
//              DMACON_BLTPRI |  // Blitter gets priority over CPU
                DMACON_DMAEN |   // Enable DMA
                DMACON_BPLEN |   // Bitplane DMA
                DMACON_BLTEN;    // Blitter DMA

    *INTENA   = INTENA_SETCLR |  // Set
                INTENA_INTEN |   // Enable interrupts
                INTENA_VERTB;    // Vertical blank

    dbg_all_scroll = 25;  // If scrolling, start by scrolling all bitplanes
}
